# Development Guide

This guide covers the development workflow, best practices, and advanced development topics for Travellers Palm.

## 📋 Table of Contents

- [Development Workflow](#development-workflow)
- [Code Organization](#code-organization)
- [Testing Strategy](#testing-strategy)
- [Debugging](#debugging)
- [Performance](#performance)
- [Best Practices](#best-practices)
- [Contributing](#contributing)

## 🔄 Development Workflow

### Daily Development

```bash
# 1. Start development server
carton exec -- morbo -l http://*:3000 script/travellers_palm

# 2. Make changes to code/templates
# Files are automatically reloaded in morbo

# 3. Test changes
curl http://localhost:3000/your-endpoint

# 4. Run relevant tests
carton exec -- prove -lv t/specific-test.t
```

### Smart Restart System

Use our intelligent restart script for Docker development:

```bash
# Smart restart - checks dependencies and rebuilds if needed
./restart.sh

# Force rebuild (when adding new modules)
./restart.sh --build

# Fast restart (skip rebuild, use when only code/templates changed)
./restart.sh --no-build
```

### Dependency Management

```bash
# Add new dependency
echo 'requires "Module::Name", ">=1.0";' >> cpanfile

# Install new dependencies
carton install

# Update all dependencies
carton update

# Lock dependencies for production
carton install --deployment
```

## 🏗️ Code Organization

### Application Structure

```
lib/TravellersPalm/
├── TravellersPalm.pm           # Main application class
├── Controller/                 # Web controllers
│   ├── Admin.pm               # Admin interface
│   ├── Destinations.pm        # Destinations management
│   ├── Users.pm               # User management
│   └── Api.pm                 # API endpoints
├── Database/                   # Database layer
│   ├── Core/                  # Infrastructure modules
│   │   ├── Connector.pm       # Database connection management
│   │   ├── Validation.pm      # Input validation utilities
│   │   └── Initializer.pm     # Database initialization and seeding
│   ├── General.pm             # Common queries
│   ├── Themes.pm              # Theme-related queries
│   ├── Cities.pm              # City data access
│   ├── Users.pm               # User data access
│   └── Images.pm              # Image management
├── Cache.pm                   # Caching system
├── Hooks.pm                   # Application hooks & middleware
├── Logger.pm                  # Logging system
├── Mailer.pm                  # Email system
└── Routes.pm                  # URL routing
```

### Database Architecture

#### Core Infrastructure

The database layer is organized with infrastructure modules in the Core namespace:

- **`Database/Core/Connector.pm`** - Database connection management and pooling
- **`Database/Core/Validation.pm`** - Centralized input validation utilities  
- **`Database/Core/Initializer.pm`** - Database initialization and seeding from CSV files
- **Backward Compatibility** - Shims available at old paths for compatibility during transitions

#### Validation System

The validation system provides comprehensive input validation with these utilities:

- **`validate_string()`** - String length and required field checks
- **`validate_integer()`** - Integer format and range validation
- **`validate_filter()`** - Whitelist-based filter validation
- **`validate_order()`** - Safe ORDER BY column validation
- **`validate_array()`** - Array element validation with callbacks

**Security Features:**
- SQL injection protection via parameter validation
- Graceful error handling with meaningful error messages
- Consistent validation patterns across all database modules
- Clear error messages with parameter names

**Applied to all database modules** (Cities, Users, Images, States, Themes, etc.) ensuring consistent data integrity and security throughout the application.

### Adding New Features

#### 1. Create Controller
```perl
# lib/TravellersPalm/Controller/NewFeature.pm
package TravellersPalm::Controller::NewFeature;
use Mojo::Base 'Mojolicious::Controller', -signatures;

sub index ($self) {
    $self->render(template => 'new_feature/index');
}

sub create ($self) {
    # Handle form submission
    my $data = $self->req->json || $self->req->params->to_hash;
    
    # Validate and process
    # ...
    
    $self->render(json => {success => 1});
}

1;
```

#### 2. Add Routes
```perl
# In lib/TravellersPalm/Routes.pm
sub setup_routes {
    my $r = shift;
    
    # Add your routes
    my $new_feature = $r->under('/new-feature');
    $new_feature->get('/')->to('NewFeature#index');
    $new_feature->post('/')->to('NewFeature#create');
}
```

#### 3. Create Templates
```html
<!-- templates/new_feature/index.html.tt -->
[% INCLUDE 'header.html.tt' %]

<h1>New Feature</h1>
<form method="post">
    <!-- Your form content -->
    <button type="submit">Submit</button>
</form>

[% INCLUDE 'footer.html.tt' %]
```

#### 4. Add Tests
```perl
# t/new-feature.t
use Test::More;
use Test::Mojo;

my $t = Test::Mojo->new('TravellersPalm');

# Test the index page
$t->get_ok('/new-feature')
  ->status_is(200)
  ->content_like(qr/New Feature/);

# Test form submission
$t->post_ok('/new-feature' => form => {field => 'value'})
  ->status_is(200)
  ->json_is('/success' => 1);

done_testing();
```

## 🧪 Testing Strategy

### Test Types

#### Unit Tests
```bash
# Test individual modules
carton exec -- prove -lv t/01-startup.t    # Basic app loading
carton exec -- prove -lv t/11-home.t       # Home page functionality
carton exec -- prove -lv t/12-users.t      # User management
carton exec -- prove -lv t/13-api.t        # API endpoints
```

#### Integration Tests
```bash
# Test full workflows
carton exec -- prove -lv t/integration/
```

#### Docker Tests
```bash
# Test in production-like environment
./bin/test-in-docker.sh
```

#### Cross-Platform Testing

The project includes Docker test helpers for cross-platform development:

- **Windows**: `.\bin\test-in-docker.ps1` - PowerShell wrapper for Windows
- **Linux/macOS/WSL**: `bash bin/test-in-docker.sh` - Bash wrapper for Unix-like systems

These helpers provide:
- Full test suite compatibility with Docker environment
- Consistent testing experience across different development platforms
- Production-like testing environment without local dependency management
- Isolated testing that doesn't interfere with local development setup

```bash
# Usage examples
.\bin\test-in-docker.ps1        # Windows PowerShell
bash bin/test-in-docker.sh      # Unix-like systems
```

### Writing Tests

#### Controller Testing
```perl
use Test::Mojo;

my $t = Test::Mojo->new('TravellersPalm');

# Test GET request
$t->get_ok('/destinations/india')
  ->status_is(200)
  ->content_type_is('text/html;charset=UTF-8')
  ->content_like(qr/India/);

# Test POST with authentication
$t->post_ok('/admin/login' => form => {
    username => 'admin',
    password => 'password'
})->status_is(302);

# Test API endpoint
$t->post_ok('/api/destinations' => json => {
    name => 'New Destination',
    country => 'India'
})->status_is(201)
  ->json_is('/success' => 1);
```

#### Database Testing
```perl
# Test database operations
my $db = $app->database;
my $result = $db->selectrow_hashref(
    'SELECT * FROM destinations WHERE name = ?',
    undef, 'Test Destination'
);
ok($result, 'Destination found in database');
```

### Test Data Management

```bash
# Reset test database
rm data/test_*.db
carton exec -- prove -lv t/

# Use test-specific database
MOJO_MODE=testing carton exec -- prove -lv t/
```

## 🐛 Debugging

### Logging

#### Enable Debug Logging
```bash
# During development
MOJO_LOG_LEVEL=debug carton exec -- morbo script/travellers_palm

# View logs
tail -f log/travellers_palm.log.*
```

#### Add Debug Statements
```perl
# In controllers
$self->app->log->debug("Debug message: " . Dumper($data));

# In application code
$app->log->info("User logged in: $username");
$app->log->error("Database error: $error");
```

### Error Investigation

#### Email Error Analysis
```perl
# Trigger test error
curl http://localhost:3000/debug_500

# Check error email logs
docker logs travellers_palm_app | grep "EMAIL SENT"
```

#### Database Debugging
```bash
# Access database directly
sqlite3 data/main.db
.tables
.schema destinations
SELECT * FROM destinations LIMIT 5;
```

### Development Tools

#### Mojolicious Built-in Tools
```bash
# Generate controller
carton exec -- mojo generate controller NewController

# Generate tests
carton exec -- mojo generate test new_feature

# App information
carton exec -- perl script/travellers_palm routes
carton exec -- perl script/travellers_palm eval 'say app->home'
```

#### Custom Debug Scripts
```bash
# Test OAuth2 configuration
carton exec -- perl script/debug_oauth2.pl

# Test email connectivity
carton exec -- perl script/test_email_connectivity.pl

# Test HTTP endpoints
carton exec -- perl script/test_http_direct.pl
```

## ⚡ Performance

### Profiling

```bash
# Enable profiling
NYTPROF=start=begin:addpid=1 carton exec -- morbo script/travellers_palm

# Generate profile report
nytprofhtml
```

### Caching

#### Memcached Integration
```perl
# In controllers
my $cache_key = "destinations:$country";
my $data = $self->app->cache->get($cache_key);

unless ($data) {
    $data = $self->database->get_destinations($country);
    $self->app->cache->set($cache_key, $data, 3600); # 1 hour
}
```

#### Template Caching
```perl
# Cache rendered templates
$self->render(
    template => 'destinations/list',
    cache_key => "dest_list_$country",
    cache_duration => 1800  # 30 minutes
);
```

### Database Optimization

```sql
-- Add indexes for frequently queried columns
CREATE INDEX idx_destinations_country ON destinations(country);
CREATE INDEX idx_hotels_destination_id ON hotels(destination_id);

-- Analyze query performance
EXPLAIN QUERY PLAN SELECT * FROM destinations WHERE country = 'India';
```

## 🎯 Best Practices

### Code Style

#### Perl Conventions
```perl
# Use modern Perl features
use v5.20;
use strict;
use warnings;
use signatures;
no warnings 'experimental::signatures';

# Clear function signatures
sub process_booking ($self, $user_id, $hotel_id, $dates) {
    # Implementation
}

# Proper error handling
eval {
    $self->database->create_booking(@args);
    1;
} or do {
    $self->app->log->error("Booking failed: $@");
    return $self->render(json => {error => 'Booking failed'}, status => 500);
};
```

#### Template Best Practices
```html
<!-- Use semantic HTML -->
<article class="destination">
    <header>
        <h1>[% destination.name | html %]</h1>
    </header>
    <section class="description">
        [% destination.description | html %]
    </section>
</article>

<!-- Always escape user content -->
[% user_input | html %]
[% json_data | json %]
```

### Security Practices

#### Input Validation
```perl
# Validate all inputs
my $validation = $self->validation;
$validation->required('email')->like(qr/\@/);
$validation->required('name')->size(1, 100);

return $self->render(json => {errors => $validation->failed})
    if $validation->has_error;
```

#### SQL Safety
```perl
# Always use placeholders
my $result = $self->database->selectall_arrayref(
    'SELECT * FROM users WHERE email = ? AND status = ?',
    {Slice => {}}, $email, 'active'
);

# Never interpolate user input directly
# BAD: "SELECT * FROM users WHERE name = '$name'"
# GOOD: Use placeholders as above
```

### Error Handling

#### Graceful Degradation
```perl
sub get_weather_data ($self, $location) {
    eval {
        return $self->weather_api->get($location);
        1;
    } or do {
        $self->app->log->warn("Weather API failed: $@");
        return {
            temperature => 'N/A',
            condition => 'Unknown',
            error => 'Weather data unavailable'
        };
    };
}
```

### Database Management

#### Seed Versioning
```perl
# In Database/Initializer.pm
# Increment this when localdb changes
our $seed_version = "2025.11.01.002";

# This forces database re-initialization
```

#### Safe Migrations
```perl
# Always backup before migrations
sub migrate_database ($self) {
    my $backup_file = "data/backup_" . time() . ".db";
    copy("data/main.db", $backup_file) 
        or die "Backup failed: $!";
    
    # Proceed with migration
    # ...
}
```

## 🤝 Contributing

### Code Review Checklist

- [ ] Tests pass: `carton exec -- prove -lv t/`
- [ ] Code follows style guidelines
- [ ] Security: Input validation and output escaping
- [ ] Performance: Efficient database queries
- [ ] Documentation: Comments for complex logic
- [ ] Logging: Appropriate log levels
- [ ] Error handling: Graceful failure modes

### Pull Request Process

1. **Feature Branch**: `git checkout -b feature/amazing-feature`
2. **Development**: Write code following best practices
3. **Testing**: Add/update tests for new functionality
4. **Documentation**: Update relevant documentation
5. **Commit**: Clear, descriptive commit messages
6. **Push**: `git push origin feature/amazing-feature`
7. **Pull Request**: Open PR with detailed description

### Commit Message Format

```
type(scope): brief description

Detailed explanation of changes made and why.

- Feature: Add new functionality
- Fix: Bug fixes
- Docs: Documentation updates
- Style: Code formatting changes
- Refactor: Code restructuring
- Test: Adding or updating tests
```

## 📚 Additional Resources

- [Mojolicious Documentation](https://mojolicious.org/perldoc)
- [Template Toolkit Manual](http://template-toolkit.org/docs/manual/)
- [DBI Documentation](https://metacpan.org/pod/DBI)
- [Email System Guide](EMAIL_SYSTEM.md)
- [Configuration Guide](CONFIGURATION.md)
- [Deployment Guide](DEPLOYMENT.md)

Happy coding! 🚀